/******************************************************************************/
/*!
\file	CatmullRomSpline.cs
\author Ng Tian Kiat
\par	email: tiankiat.ng\@digipen.edu
\details
	This script moves a gameobject along a series of waypoints generated by a spline,
    script (Catmullrom).

\copyright	Copyright (c) 2021 DigiPen Institute of Technology. Reproduction
			or disclosure of this file or its contents without the prior
			written consent of DigiPen Institute of Technology is prohibited.
*/
/******************************************************************************/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Scripting
{
    class CatmullRomSpline
	{
        public Transform[] controlPointsList = new Transform[8];

		public bool isLooping = false;

		public float step_size = 0.2f;

		public CatmullRomSpline()
        {
			// Test spline constructed here

			//controlPointsList[0].SetPositionAndRotatation(new Vector3(0.0f, 0.0f, 0.0f), new Vector3(0.0f, 0.0f, 0.0f));
			controlPointsList[0].SetPositionAndRotatation(Vector3.Zero(), Vector3.Zero());
			controlPointsList[1].SetPositionAndRotatation(new Vector3(20.0f, 0.0f, 0.0f), new Vector3(0.0f, 0.0f, 0.0f));
			controlPointsList[2].SetPositionAndRotatation(new Vector3(40.0f, 0.0f, 0.0f), new Vector3(0.0f, 0.0f, 0.0f));
			controlPointsList[3].SetPositionAndRotatation(new Vector3(80.0f, 0.0f, 0.0f), new Vector3(0.0f, 0.0f, 0.0f));
			controlPointsList[4].SetPositionAndRotatation(new Vector3(100.0f, 0.0f, 0.0f), new Vector3(0.0f, 0.0f, 0.0f));
			controlPointsList[5].SetPositionAndRotatation(new Vector3(120.0f, 0.0f, 0.0f), new Vector3(0.0f, 0.0f, 0.0f));
			controlPointsList[6].SetPositionAndRotatation(new Vector3(140.0f, 0.0f, 0.0f), new Vector3(0.0f, 0.0f, 0.0f));
			controlPointsList[7].SetPositionAndRotatation(new Vector3(160.0f, 0.0f, 0.0f), new Vector3(0.0f, 0.0f, 0.0f));
		}

		//Display a spline between 2 points derived with the Catmull-Rom spline algorithm
		void DisplayCatmullRomSpline(int pos)
		{
			//The 4 points we need to form a spline between p1 and p2
			Vector3 p0 = controlPointsList[ClampListPos(pos - 1)].Position;
			Vector3 p1 = controlPointsList[pos].Position;
			Vector3 p2 = controlPointsList[ClampListPos(pos + 1)].Position;
			Vector3 p3 = controlPointsList[ClampListPos(pos + 2)].Position;

			//The start position of the line
			Vector3 lastPos = p1;

			//The spline's resolution
			//Make sure it's is adding up to 1, so 0.3 will give a gap, but 0.2 will work

			//How many times should we loop?
			int loops = (int)(1f / step_size);

			for (int i = 1; i <= loops; i++)
			{
				//Which t position are we at?
				float t = i * step_size;

				//Find the coordinate between the end points with a Catmull-Rom spline
				Vector3 newPos = GetCatmullRomPosition(t, p0, p1, p2, p3);

				//Draw this line segment
				//Gizmos.DrawLine(lastPos, newPos);
				//DrawSphere(newPos, 0.1f);

				//Save this pos so we can draw the next line segment
				lastPos = newPos;
			}
		}

		// Links a series of splines into chains and returns their waypoints.
		public List<Vector3> CalculateCatmullRomChain()
		{
			// Resulting waypoint of the entire spline chain
			List<Vector3> waypoints = new List<Vector3>();
			int remove_range = (int)(10 / (step_size * 10));
			for (int i = 1; i < controlPointsList.Length; i++)
			{
				if ((i == controlPointsList.Length - 1) && !isLooping)
				{
					continue;
				}
				// Calculate the waypoints for one spline section 
				// and add it to the waypoints.
				waypoints.AddRange(CalculateCatmullRomSpline(i));
			}
			// Cull the start and end of the waypoint array because they are screwed up
			waypoints.RemoveRange(0, remove_range);
			//for (int i = 0; i < remove_range; ++i)
			//	waypoints.RemoveAt(waypoints.Count);
			return waypoints;
		}

		// Given a starting index, this generates a spline section of the entire chain and returns a series of waypoints.
		List<Vector3> CalculateCatmullRomSpline(int pos)
		{
			List<Vector3> waypoints = new List<Vector3>();
			//The 4 points we need to form a spline between p1 and p2
			Vector3 p0 = controlPointsList[ClampListPos(pos - 1)].Position;
			Vector3 p1 = controlPointsList[pos].Position;
			Vector3 p2 = controlPointsList[ClampListPos(pos + 1)].Position;
			Vector3 p3 = controlPointsList[ClampListPos(pos + 2)].Position;

			//Console.WriteLine("p " + 0 + " is at: x = " + p0.X + ", y = " + p0.Y + ", z = " + p0.Z);
			//Console.WriteLine("p " + 1 + " is at: x = " + p1.X + ", y = " + p1.Y + ", z = " + p1.Z);
			//Console.WriteLine("p " + 2 + " is at: x = " + p2.X + ", y = " + p2.Y + ", z = " + p2.Z);
			//Console.WriteLine("p " + 3 + " is at: x = " + p3.X + ", y = " + p3.Y + ", z = " + p3.Z);

			//The start position of the line
			Vector3 lastPos = p1;

			//The spline's resolution
			//Make sure it's is adding up to 1, so 0.3 will give a gap, but 0.2 will work

			//How many times should we loop?
			int loops = (int)(1f / step_size);

			for (int i = 1; i <= loops; i++)
			{
				//Which t position are we at?
				float t = i * step_size;

				//Find the coordinate between the end points with a Catmull-Rom spline
				Vector3 newPos = GetCatmullRomPosition(t, p0, p1, p2, p3);

				//Console.WriteLine("waypoint " + i + " is at: x = " + newPos.X + ", y = " + newPos.Y + ", z = " + newPos.Z);

				waypoints.Add(newPos);

				//Save this pos so we can draw the next line segment
				lastPos = newPos;
			}
			return waypoints;
		}

		//Clamp the list positions to allow looping
		int ClampListPos(int pos)
		{
			if (pos < 0)
			{
				pos = controlPointsList.Length - 1;
			}

			if (pos > controlPointsList.Length)
			{
				pos = 1;
			}
			else if (pos > controlPointsList.Length - 1)
			{
				pos = 0;
			}

			return pos;
		}

		//Returns a position between 4 Vector3 with Catmull-Rom spline algorithm
		//http://www.iquilezles.org/www/articles/minispline/minispline.htm
		Vector3 GetCatmullRomPosition(float t, Vector3 p0, Vector3 p1, Vector3 p2, Vector3 p3)
		{
            //The coefficients of the cubic polynomial (except the 0.5f * which I added later for performance)
            //Console.WriteLine("p " + 0 + " is at: x = " + p0.X + ", y = " + p0.Y + ", z = " + p0.Z);
            //Console.WriteLine("p " + 1 + " is at: x = " + p1.X + ", y = " + p1.Y + ", z = " + p1.Z);
            //Console.WriteLine("p " + 2 + " is at: x = " + p2.X + ", y = " + p2.Y + ", z = " + p2.Z);
            //Console.WriteLine("p " + 3 + " is at: x = " + p3.X + ", y = " + p3.Y + ", z = " + p3.Z);

            Vector3 a = 2f * p1;
			Vector3 b = p2 - p0;
			//Vector3 c = 2f * p0 - 5f * p1 + 4f * p2 - p3;
			Vector3 c = (2f * p0) - (5f * p1) + (4f * p2) - p3;
			//Vector3 d = -p0 + 3f * p1 - 3f * p2 + p3;
			Vector3 d = -p0 + (3f * p1) - (3f * p2) + p3;

			//Console.WriteLine("a "  + " is at: x = " + a.X + ", y = " + a.Y + ", z = " + a.Z);
			//Console.WriteLine("b "  + " is at: x = " + b.X + ", y = " + b.Y + ", z = " + b.Z);
			//Console.WriteLine("c "  + " is at: x = " + c.X + ", y = " + c.Y + ", z = " + c.Z);
			//Console.WriteLine("d "  + " is at: x = " + d.X + ", y = " + d.Y + ", z = " + d.Z);

			//The cubic polynomial: a + b * t + c * t^2 + d * t^3
			//Vector3 pos = 0.5f * (a + (b * t) + (c * t * t) + (d * (t * t * t)));

			Vector3 pos = 0.5f * (a + (b * t) + (c * (t * t)) + (d * (t * t * t)));

			return pos;
		}
	}
}
